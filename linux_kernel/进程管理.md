### 进程

进程包括：

- 一段可执行程序代码
- 打开的文件
- 挂起的信号
- 内核内部数据
- 处理器状态
- 一个或多个具有内存映射的内存地址空间及一个或多个执行线程
- 用来存放全局变量的数据段

内核调度的对象是线程，不是进程

现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虽然实际上是多个进程共享一个处理器，但虚拟处理器给进程一个假象，让这些进程觉得自己在独享处理器；虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。



调用fork()的进程为父进程，调用fork()产生的进程叫做子进程；调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中；最终，通过exit()系统调用退出执行，这个函数会中介进程并将其占用的资源释放掉。父进程可以可以通过wait()系统调用查询子进程是否终结。

 

#### current宏

内核中，可以通过current宏来获得当前执行进程的task_struct指针。

最原始的定义如下：

```c++
#define current get_current()

#define get_current()(current_thread_info()->task)
//可以看出,current调用了current_thread_info函数，此函数的内核路径为： /arch/arm/include/asm/thread_info.h
```

通过current宏在找到thread_info结构体；在通过thread_info中的struct task_struct *task来找到当前的进程描述符，通过进程描述符来访问任务（即进程）。

```c++
struct thread_info{
   unsigned long		flags;		/* low level flags */
	int			preempt_count;	/* 0 => preemptable, <0 => bug */
	mm_segment_t		addr_limit;	/* address limit */
	struct task_struct	*task;		/* main task structure */
	struct exec_domain	*exec_domain;	/* execution domain */
	__u32			cpu;		/* cpu */
	__u32			cpu_domain;	/* cpu domain */
	struct cpu_context_save	cpu_context;	/* cpu context */
	__u32			syscall;	/* syscall number */
	__u8			used_cp[16];	/* thread used copro */
	unsigned long		tp_value;
	struct crunch_state	crunchstate;
	union fp_state		fpstate __attribute__((aligned(8)));
	union vfp_state		vfpstate;
#ifdef CONFIG_ARM_THUMBEE
	unsigned long		thumbee_state;	/* ThumbEE Handler Base register */
#endif
	struct restart_block	restart_block;
}
```

thread_info中嵌入了struct_task（进程描述符）的指针，所以可以很方便的通过thread_info来查找struct_task;

linux将内核栈和进程控制块thread_info融合在一起，组成一个联合体thread_union;通常内核栈和thread_info一同保存在一个联合体中，thread_info保存了所有线程所需的所有特定处理器的信息，以及通用的task_struct的指针。

#### thread_union

对每个进程,linux内核都把两个不同的数据结构存放在 一个单独为进程分配的内存区域中：

- 一个内核态的进程堆栈stack
- 另一个是紧挨着进程描述符的小数据结构thread_info,叫做线程描述符

这两个结构被紧凑的放在一个联合体中的thread_union中

```c++
union thread_union
{
	struct thread_info thread_info;
	unsigned long stack [THRAED_SIZE/sizeof(long)];
}
```

同时我们可以看到,

- thread_info和内核栈虽然共用了thread_union结构, 但是thread_info大小固定, 存储在联合体的开始部分, 而内核栈由高地址向低地址扩展, 当内核栈的栈顶到达thread_info的存储空间时, 则会发生栈溢出
- 系统的current指针指向了当前运行进程的thread_union(或者thread_info)的地址
- 进程task_struct中的stack指针指向了进程的thread_union(或者thread_info)的地址, 在早期的内核中这个指针用struct thread_info *thread_info来表示, 但是新的内核中用了一个更浅显的名字void *stack, 即内核栈

即，进程的thread_info存储在进程内核栈的最低端

#### 进程描述符及任务结构

内核把进程的列表存放在叫做任务队列（task list）的双向循环链表中。链表中的每一项都是类型为task_struct、称为进程描述符的结构，该结构定义在<linux/sched.h>文件中

```c++
struct task_struct {
volatile long state;  //说明了该进程是否可以执行,还是可中断等信息
unsigned long flags;  //Flage 是进程号,在调用fork()时给出
int sigpending;    //进程上是否有待处理的信号
mm_segment_t addr_limit; //进程地址空间,区分内核进程与普通进程在内存存放的位置不同
                        //0-0xBFFFFFFF for user-thead
                        //0-0xFFFFFFFF for kernel-thread
//调度标志,表示该进程是否需要重新调度,若非0,则当从内核态返回到用户态,会发生调度
volatile long need_resched;
int lock_depth;  //锁深度
long nice;       //进程的基本时间片
//进程的调度策略,有三种,实时进程:SCHED_FIFO,SCHED_RR, 分时进程:SCHED_OTHER
unsigned long policy;
struct mm_struct *mm; //进程内存管理信息
int processor;
//若进程不在任何CPU上运行, cpus_runnable 的值是0，否则是1 这个值在运行队列被锁时更新
unsigned long cpus_runnable, cpus_allowed;
struct list_head run_list; //指向运行队列的指针
unsigned long sleep_time;  //进程的睡眠时间
//用于将系统中所有的进程连成一个双向循环链表, 其根是init_task
struct task_struct *next_task, *prev_task;
struct mm_struct *active_mm;
struct list_head local_pages;       //指向本地页面      
unsigned int allocation_order, nr_local_pages;
struct linux_binfmt *binfmt;  //进程所运行的可执行文件的格式
int exit_code, exit_signal;
int pdeath_signal;     //父进程终止时向子进程发送的信号
unsigned long personality;
//Linux可以运行由其他UNIX操作系统生成的符合iBCS2标准的程序
int did_exec:1; 
pid_t pid;    //进程标识符,用来代表一个进程
pid_t pgrp;   //进程组标识,表示进程所属的进程组
pid_t tty_old_pgrp;  //进程控制终端所在的组标识
pid_t session;  //进程的会话标识
pid_t tgid;
int leader;     //表示进程是否为会话主管
struct task_struct *p_opptr,*p_pptr,*p_cptr,*p_ysptr,*p_osptr;
struct list_head thread_group;   //线程链表
struct task_struct *pidhash_next; //用于将进程链入HASH表
struct task_struct **pidhash_pprev;
wait_queue_head_t wait_chldexit;  //供wait4()使用
struct completion *vfork_done;  //供vfork() 使用
unsigned long rt_priority; //实时优先级，用它计算实时进程调度时的weight值
 
//it_real_value，it_real_incr用于REAL定时器，单位为jiffies, 系统根据it_real_value
//设置定时器的第一个终止时间. 在定时器到期时，向进程发送SIGALRM信号，同时根据
//it_real_incr重置终止时间，it_prof_value，it_prof_incr用于Profile定时器，单位为jiffies。
//当进程运行时，不管在何种状态下，每个tick都使it_prof_value值减一，当减到0时，向进程发送
//信号SIGPROF，并根据it_prof_incr重置时间.
//it_virt_value，it_virt_value用于Virtual定时器，单位为jiffies。当进程运行时，不管在何种
//状态下，每个tick都使it_virt_value值减一当减到0时，向进程发送信号SIGVTALRM，根据
//it_virt_incr重置初值。
unsigned long it_real_value, it_prof_value, it_virt_value;
unsigned long it_real_incr, it_prof_incr, it_virt_value;
struct timer_list real_timer;   //指向实时定时器的指针
struct tms times;      //记录进程消耗的时间
unsigned long start_time;  //进程创建的时间
//记录进程在每个CPU上所消耗的用户态时间和核心态时间
long per_cpu_utime[NR_CPUS], per_cpu_stime[NR_CPUS]; 
//内存缺页和交换信息:
//min_flt, maj_flt累计进程的次缺页数（Copy on　Write页和匿名页）和主缺页数（从映射文件或交换
//设备读入的页面数）； nswap记录进程累计换出的页面数，即写到交换设备上的页面数。
//cmin_flt, cmaj_flt, cnswap记录本进程为祖先的所有子孙进程的累计次缺页数，主缺页数和换出页面数。
//在父进程回收终止的子进程时，父进程会将子进程的这些信息累计到自己结构的这些域中
unsigned long min_flt, maj_flt, nswap, cmin_flt, cmaj_flt, cnswap;
int swappable:1; //表示进程的虚拟地址空间是否允许换出
//进程认证信息
//uid,gid为运行该进程的用户的用户标识符和组标识符，通常是进程创建者的uid，gid
//euid，egid为有效uid,gid
//fsuid，fsgid为文件系统uid,gid，这两个ID号通常与有效uid,gid相等，在检查对于文件
//系统的访问权限时使用他们。
//suid，sgid为备份uid,gid
uid_t uid,euid,suid,fsuid;
gid_t gid,egid,sgid,fsgid;
int ngroups; //记录进程在多少个用户组中
gid_t groups[NGROUPS]; //记录进程所在的组
//进程的权能，分别是有效位集合，继承位集合，允许位集合
kernel_cap_t cap_effective, cap_inheritable, cap_permitted;
int keep_capabilities:1;
struct user_struct *user;
struct rlimit rlim[RLIM_NLIMITS];  //与进程相关的资源限制信息
unsigned short used_math;   //是否使用FPU
char comm[16];   //进程正在运行的可执行文件名
 //文件系统信息
int link_count, total_link_count;
//NULL if no tty 进程所在的控制终端，如果不需要控制终端，则该指针为空
struct tty_struct *tty;
unsigned int locks;
//进程间通信信息
struct sem_undo *semundo;  //进程在信号灯上的所有undo操作
struct sem_queue *semsleeping; //当进程因为信号灯操作而挂起时，他在该队列中记录等待的操作
//进程的CPU状态，切换时，要保存到停止进程的task_struct中
struct thread_struct thread;
  //文件系统信息
struct fs_struct *fs;
  //打开文件信息
struct files_struct *files;
  //信号处理函数
spinlock_t sigmask_lock;
struct signal_struct *sig; //信号处理函数
sigset_t blocked;  //进程当前要阻塞的信号，每个信号对应一位
struct sigpending pending;  //进程上是否有待处理的信号
unsigned long sas_ss_sp;
size_t sas_ss_size;
int (*notifier)(void *priv);
void *notifier_data;
sigset_t *notifier_mask;
u32 parent_exec_id;
u32 self_exec_id;
 
spinlock_t alloc_lock;
void *journal_info;
}
```

#### 进程状态state

进程描述符中的state域描述了进程的当前状态，每个进程必处于以下五种状态种的一种：

- TASK_RUNNING(运行)
- TASK_INTERRUPTABLE（可中断）
- TASK_UNINTERRUPTIBLE(不可中断)
- _TASK_TRACED(被其他进程跟踪的进程)
- _TASK_STOPPED(停止)

![image-20201108222708794](/home/tuony/.config/Typora/typora-user-images/image-20201108222708794.png)

可通过set_task_state(task,state)或者set_current_state(state)来调整某个进程的状态。

一般程序在用户空间执行，当一个程序执行了系统调用或者触发了某个异常，它就陷入了内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。

#### 进程家族树

所有的进程都是PID为1的init进程后代。系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。进程间的关系存放在进程描述符当中，每个task_struct都包含一个指向其父进程tast_strcut、叫做parent的指针，还包含一个称为children的子进程链表。

init进程的进程描述符是组委init_task静态分配的。下面的代码可以很好地演示所有进程之间的关系：

```c++
strcut task_struct *task;
for(task=current;task!=&init_task;task=task->parrent);
//task现在指向init
```

对于给定的进程，获取链表中的下一个进程：

```c++
list_entry(task->tasks.next,struct task_struct,tasks)
```

获取前一个进程：

```c++
list_entry(task->tasks.prev,struct task_struct,tasks)
```

这两个例程分别通过next_task(task)宏和prev_task(task)宏来实现。而实际上，for_each_process(task)宏提供了一次访问整个任务队列的能力。每次访问，任务指针都指向链表中的下个元素：

```c++
struct task_struct *task;
for_each_process(task){
		printk("%s[%d]\n",task->com,task->pid);
}
```

